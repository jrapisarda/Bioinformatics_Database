"""
Recommendation generation logic.

This module orchestrates the combination of unsupervised machine
learning scores, rule evaluation scores and baseline similarity into a
final composite ranking for gene pair recommendations. It provides
utilities to compute final scores, generate explanations and assemble
structured result objects suitable for downstream consumption by the
web interface or APIs.
"""

from __future__ import annotations

from typing import List, Dict, Tuple, Any

import pandas as pd

from .data_processing import compute_baseline_similarity
from .ml_models import compute_ml_scores
from .rule_engine import evaluate_rules


def generate_recommendations(
    df_features: pd.DataFrame,
    rules: List[Dict[str, Any]],
    baseline_pair: Tuple[str, str],
    top_n: int = 20,
) -> Dict[str, Any]:
    """Generate ranked recommendations for gene pairs.

    This function accepts a DataFrame containing engineered features
    (see :func:`gene_pair_project.data_processing.engineer_features`), a
    list of rule definitions, and a positive control pair. It
    computes ML scores and baseline similarity, evaluates rules and
    assembles a final ranking based on weighted contributions.

    Parameters
    ----------
    df_features : DataFrame
        DataFrame of engineered features for each pair. Must include
        the original gene names (``GeneAName``, ``GeneBName``) and
        engineered columns generated by :func:`engineer_features`.
    rules : list of dict
        Rule definitions to apply to each pair.
    baseline_pair : tuple
        Tuple of (geneA, geneB) representing the positive control.
    top_n : int, default=20
        Number of top recommendations to return.

    Returns
    -------
    dict
        Dictionary containing ``analysis_summary`` and ``recommendations``. The
        ``analysis_summary`` includes aggregate metrics such as the number
        of total pairs, outliers detected and cluster counts. Each
        element in ``recommendations`` is a dictionary with keys:
        ``gene_a``, ``gene_b``, ``combined_score``, ``ml_confidence``,
        ``rules_score``, ``baseline_similarity``, ``is_outlier``,
        ``cluster_label``, ``rank`` and ``rule_explanations``.
    """
    df = df_features.copy()

    # Compute baseline similarity and update DataFrame
    df["baseline_similarity"] = compute_baseline_similarity(df, baseline_pair)

    # Compute ML scores, outlier flags and cluster labels
    ml_scores, is_outlier, cluster_labels = compute_ml_scores(df)
    df["ml_score"] = ml_scores
    df["is_outlier"] = is_outlier
    df["cluster_label"] = cluster_labels

    # Evaluate rules on each row
    total_rule_weight = sum(float(rule["weight"]) for rule in rules)
    rule_scores: List[float] = []
    rule_explanations: List[List[str]] = []
    for _, row in df.iterrows():
        pair_data = row.to_dict()
        score, explanations = evaluate_rules(pair_data, rules)
        # Normalise rule score by total weight (avoid division by zero)
        normalised_score = score / total_rule_weight if total_rule_weight > 0 else 0.0
        rule_scores.append(normalised_score)
        rule_explanations.append(explanations)
    df["rules_score"] = rule_scores
    df["rule_explanations"] = rule_explanations

    # Statistical strength bonus: normalised measure of effect magnitude
    # Prefer combined_effect_size absolute value; fall back to abs_delta_effect_size if present, else zero.
    stat_raw = None
    if "combined_effect_size" in df.columns:
        stat_raw = df["combined_effect_size"].abs()
    elif "abs_delta_effect_size" in df.columns:
        stat_raw = df["abs_delta_effect_size"]

    if stat_raw is not None and stat_raw.max() - stat_raw.min() > 0:
        stat_bonus = (stat_raw - stat_raw.min()) / (stat_raw.max() - stat_raw.min())
    else:
        stat_bonus = pd.Series(0.0, index=df.index)

    df["stat_bonus"] = stat_bonus

    # Combine scores according to weighting scheme
    df["combined_score"] = (
        0.35 * df["ml_score"]
        + 0.35 * df["rules_score"]
        + 0.20 * df["baseline_similarity"]
        + 0.10 * df["stat_bonus"]
    )

    # Sort by combined score descending
    df_sorted = df.sort_values(by="combined_score", ascending=False)

    # Determine high confidence: arbitrarily require all components > 0.5
    df_sorted["is_high_confidence"] = (
        (df_sorted["ml_score"] > 0.6)
        & (df_sorted["rules_score"] > 0.5)
        & (df_sorted["baseline_similarity"] > 0.7)
    )

    # Build recommendation objects
    recommendations: List[Dict[str, Any]] = []
    for rank, (_idx, row) in enumerate(df_sorted.head(top_n).iterrows(), start=1):
        rec = {
            "gene_a": row["GeneAName"],
            "gene_b": row["GeneBName"],
            "rules_score": float(row["rules_score"]),
            "ml_confidence": float(row["ml_score"]),
            "baseline_similarity": float(row["baseline_similarity"]),
            "combined_score": float(row["combined_score"]),
            "is_high_confidence": bool(row["is_high_confidence"]),
            "is_outlier": bool(row["is_outlier"]),
            "cluster_label": int(row["cluster_label"]),
            "rank": rank,
            "statistical_measures": {
                "p_ss": row.get("p_ss"),
                "p_soth": row.get("p_soth"),
                "dz_ss_mean": row.get("dz_ss_mean"),
                "dz_soth_mean": row.get("dz_soth_mean"),
                "q_ss": row.get("q_ss"),
                "q_soth": row.get("q_soth"),
            },
            "rule_explanations": row["rule_explanations"],
        }
        recommendations.append(rec)

    # Build analysis summary
    summary = {
        "total_pairs": int(len(df)),
        "outliers_detected": int(is_outlier.sum()),
        "clusters_found": int(len(set(cluster_labels)) - (1 if -1 in cluster_labels.values else 0)),
        "positive_control_validated": any(
            (df_sorted["GeneAName"] == baseline_pair[0])
            & (df_sorted["GeneBName"] == baseline_pair[1])
            & (df_sorted.index < top_n)
        ),
    }

    return {
        "analysis_summary": summary,
        "recommendations": recommendations,
    }