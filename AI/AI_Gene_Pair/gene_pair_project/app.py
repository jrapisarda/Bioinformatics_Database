"""
Flask web application for the Gene Pair Analysis project.

This application provides an interface for uploading gene pair
meta‑analysis data, configuring rule‐based ranking behaviour, and
visualising recommendations generated by the analysis pipeline. The app
utilises the modules within the :mod:`gene_pair_project` package to
load and process data, compute scores and deliver interactive
visualisations through HTML templates.

To run the server locally, install Flask (``pip install flask``) and
execute this module directly:

```
python -m gene_pair_project.app
```

By default the application uses the MS4A4A–CD86 pair as the positive
control; this can be customised via the upload form.
"""

from __future__ import annotations

import os
import uuid
from pathlib import Path
from typing import Dict, Any

from flask import (
    Flask,
    request,
    render_template,
    redirect,
    url_for,
    flash,
    send_from_directory,
)

from .data_processing import load_data, engineer_features
from .recommendation import generate_recommendations
from .rules import load_rules_config, save_rules_config, add_rule


# Create Flask application
app = Flask(__name__)
app.config["SECRET_KEY"] = os.environ.get("FLASK_SECRET_KEY", "gene_pair_secret")

# Instance directory for storing uploaded files and configuration
INSTANCE_PATH = Path(__file__).resolve().parent / "instance"
INSTANCE_PATH.mkdir(parents=True, exist_ok=True)

# Path to persist rule configuration
RULES_CONFIG_FILE = INSTANCE_PATH / "rules_config.json"

# In-memory storage for analysis results keyed by session ID
ANALYSIS_RESULTS: Dict[str, Dict[str, Any]] = {}


@app.route("/", methods=["GET", "POST"])
def index():
    """Handle the landing page and file upload.

    Users can upload CSV/Excel/JSON files containing gene pair
    statistics, specify the number of top recommendations to return and
    optionally add a new rule to the ranking engine. On submission the
    analysis runs and the user is redirected to the results page.
    """
    # Load current rule configuration
    rules = load_rules_config(RULES_CONFIG_FILE)

    if request.method == "POST":
        # Check if adding a new rule
        if request.form.get("action") == "add_rule":
            name = request.form.get("rule_name", "").strip()
            condition = request.form.get("rule_condition", "").strip()
            weight = request.form.get("rule_weight", "").strip()
            explanation = request.form.get("rule_explanation", "").strip()
            if not name or not condition or not weight:
                flash("All rule fields are required", "danger")
            else:
                try:
                    weight_val = float(weight)
                    updated_rules = add_rule(rules, name, condition, weight_val, explanation)
                    save_rules_config(RULES_CONFIG_FILE, updated_rules)
                    flash(f"Rule '{name}' added successfully", "success")
                    # Reload rules for display
                    rules = load_rules_config(RULES_CONFIG_FILE)
                except ValueError as exc:
                    flash(str(exc), "danger")
            return redirect(url_for("index"))

        # Otherwise handle file upload and analysis
        uploaded = request.files.get("data_file")
        if not uploaded or uploaded.filename == "":
            flash("Please select a file to upload", "danger")
            return redirect(url_for("index"))
        # Save uploaded file to instance folder
        file_ext = Path(uploaded.filename).suffix.lower()
        temp_filename = f"upload_{uuid.uuid4().hex}{file_ext}"
        temp_path = INSTANCE_PATH / temp_filename
        uploaded.save(temp_path)

        # Parse top_n parameter
        try:
            top_n = int(request.form.get("top_n", "20"))
        except ValueError:
            top_n = 20

        # Parse baseline pair names
        baseline_gene_a = request.form.get("baseline_gene_a", "MS4A4A").strip()
        baseline_gene_b = request.form.get("baseline_gene_b", "CD86").strip()
        baseline_pair = (baseline_gene_a, baseline_gene_b)

        try:
            df_raw = load_data(temp_path)
            df_feat = engineer_features(df_raw)
            # Load latest rules after potential additions
            rules_config = load_rules_config(RULES_CONFIG_FILE)
            results = generate_recommendations(
                df_feat, rules_config, baseline_pair, top_n=top_n
            )
            # Save results in memory under a new session ID
            session_id = uuid.uuid4().hex
            ANALYSIS_RESULTS[session_id] = results
            flash("Analysis completed successfully", "success")
            return redirect(url_for("results", session_id=session_id))
        except Exception as exc:
            flash(f"Failed to process data: {exc}", "danger")
            return redirect(url_for("index"))

    # GET request: show upload form
    return render_template(
        "index.html",
        rules=rules,
    )


@app.route("/results/<session_id>")
def results(session_id: str):
    """Display results for a completed analysis session."""
    result = ANALYSIS_RESULTS.get(session_id)
    if not result:
        flash("Invalid or expired session ID", "danger")
        return redirect(url_for("index"))

    # Prepare data for template
    analysis_summary = result.get("analysis_summary", {})
    recommendations = result.get("recommendations", [])

    # Build scatter plot data: effect sizes
    x_vals = [rec["statistical_measures"]["dz_ss_mean"] for rec in recommendations]
    y_vals = [rec["statistical_measures"]["dz_soth_mean"] for rec in recommendations]
    hover_texts = [
        f"{rec['gene_a']}–{rec['gene_b']}<br>Combined score: {rec['combined_score']:.3f}"
        for rec in recommendations
    ]
    scatter_data = {
        "data": [
            {
                "x": x_vals,
                "y": y_vals,
                "text": hover_texts,
                "mode": "markers",
                "marker": {
                    "size": 10,
                    "color": [rec["combined_score"] for rec in recommendations],
                    "colorscale": "Viridis",
                    "showscale": True,
                    "colorbar": {
                        "title": "Combined Score",
                    },
                },
            }
        ],
        "layout": {
            "title": "Effect Size Scatter Plot",
            "xaxis": {"title": "Sepsis Effect Size (dz_ss_mean)"},
            "yaxis": {"title": "Septic Shock Effect Size (dz_soth_mean)"},
            "hovermode": "closest",
        },
    }

    return render_template(
        "results.html",
        summary=analysis_summary,
        recommendations=recommendations,
        scatter_data=scatter_data,
    )


@app.route("/download/<session_id>.json")
def download_results(session_id: str):
    """Serve analysis results as a JSON file for download."""
    result = ANALYSIS_RESULTS.get(session_id)
    if not result:
        flash("Invalid or expired session ID", "danger")
        return redirect(url_for("index"))
    filename = f"results_{session_id}.json"
    filepath = INSTANCE_PATH / filename
    # Save result to file
    import json
    with open(filepath, "w", encoding="utf-8") as fh:
        json.dump(result, fh, indent=2)
    return send_from_directory(INSTANCE_PATH, filename, as_attachment=True)


def create_app() -> Flask:
    """Factory to create and configure the Flask application."""
    return app


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)